     1                                  global _start           ;делаем метку видимой извне
     2                                  
     3                                  section .data                         ; секция с данными
     4 00000000 456E74657220613A20-         input_a db "Enter a: ", 0         ; сообщение для ввода
     4 00000009 00                 
     5                                      len_in_a equ $ - input_a          ; длина сообщения
     6 0000000A 456E74657220623A20-         input_b db "Enter b: ", 0         ; сообщение для ввода
     6 00000013 00                 
     7                                      len_in_b equ $ - input_b          ; длина сообщения
     8 00000014 61202B2062203D2000          out_msg db "a + b = ", 0          ; сообщение для вывода
     9                                      len_out_msg equ $ - out_msg       ; длина сообщения
    10 0000001D 0000000000000000            len_read dq 0                     ; количество считанных байт
    11 00000025 0000000000000000            a dq 0                            ; первое число 2 байта
    12 0000002D 0000000000000000            b dq 0                            ; второе число 2 байта
    13 00000035 0100000000000000            sign dq 1                         ; знак числа для функции num_to_str
    14 0000003D 0A00000000000000            divisor dq 10                     ; делитель для функции num_to_str
    15                                  
    16                                  section .bss                       ; секция bss для неинициализированных данных
    17 00000000 <res 80h>                   buffer resb 128                ; буфер для считывания из стандартного ввода
    18 00000080 <res 80h>                   result resb 128
    19                                  
    20                                  section .text                       ; объявление секции кода
    21                                  _start:                             ; точка входа в программу
    22 00000000 B801000000                  mov rax, 1                      ; 1 - номер системного вызова функции write
    23 00000005 BF01000000                  mov rdi, 1                      ; 1 - дескриптор файла стандартного вызова stdout
    24 0000000A 48BE-                       mov rsi, input_a                ; адрес строки для вывода
    24 0000000C [0000000000000000] 
    25 00000014 BA0A000000                  mov rdx, len_in_a               ; кол-во байт которое нужно записать
    26 00000019 0F05                        syscall                         ; выполняем системный вызов write
    27                                  
    28 0000001B 4883F8FF                    cmp rax, -1                     ; сравниваем значение которое вернул write
    29 0000001F 0F84E6010000                jz err                          ; если rax = -1 то переход на метку err
    30                                  
    31 00000025 B800000000                  mov rax, 0                      ; номер системного вызова read
    32 0000002A 48BE-                       mov rsi, buffer                 ; сообщение для записи
    32 0000002C [0000000000000000] 
    33 00000034 BF00000000                  mov rdi, 0                      ; дескриптор STDIN
    34 00000039 BA80000000                  mov rdx, 128                    ; длина считываемого сообщения
    35 0000003E 0F05                        syscall                         ; выполняем системный вызов read
    36                                  
    37 00000040 48890425[1D000000]          mov [len_read], rax              ; количество байтов которые были прочитаны
    38 00000048 4883F8FF                    cmp rax, -1                      ; сравниваем значение которое вернул read
    39 0000004C 0F84B9010000                jz err                           ; если rax = -1 то переход на метку err
    40                                  
    41 00000052 E8DD000000                  call str_to_num                  ; вызов функции перевода строки в число
    42 00000057 48890425[25000000]          mov [a], rax
    43                                  
    44 0000005F B801000000                  mov rax, 1                      ; 1 - номер системного вызова функции write
    45 00000064 BF01000000                  mov rdi, 1                      ; 1 - дескриптор файла стандартного вызова stdout
    46 00000069 48BE-                       mov rsi, input_b                ; адрес строки для вывода
    46 0000006B [0A00000000000000] 
    47 00000073 BA0A000000                  mov rdx, len_in_b               ; кол-во байт которое нужно записать
    48 00000078 0F05                        syscall                         ; выполняем системный вызов write
    49                                  
    50 0000007A 4883F8FF                    cmp rax, -1                     ; сравниваем значение которое вернул write
    51 0000007E 0F8487010000                jz err                          ; если rax = -1 то переход на метку err
    52                                  
    53 00000084 B800000000                  mov rax, 0                      ; номер системного вызова read
    54 00000089 48BE-                       mov rsi, buffer                 ; сообщение для записи
    54 0000008B [0000000000000000] 
    55 00000093 BF00000000                  mov rdi, 0                      ; дескриптор STDIN
    56 00000098 BA80000000                  mov rdx, 128                    ; длина считываемого сообщения
    57 0000009D 0F05                        syscall                         ; выполняем системный вызов read
    58                                  
    59 0000009F 48890425[1D000000]          mov [len_read], rax              ; количество байтов которые были прочитаны
    60 000000A7 4883F8FF                    cmp rax, -1                      ; сравниваем значение которое вернул read
    61 000000AB 0F845A010000                jz err                           ; если rax = -1 то переход на метку err
    62                                  
    63 000000B1 E87E000000                  call str_to_num                  ; вызов функции перевода строки в число
    64 000000B6 48890425[2D000000]          mov [b], rax
    65                                  
    66 000000BE B800000000                  mov rax, 0
    67 000000C3 48030425[25000000]          add rax, [a]
    68 000000CB 48030425[2D000000]          add rax, [b]
    69 000000D3 E8A9000000                  call num_to_str
    70 000000D8 48891425[1D000000]          mov [len_read], rdx
    71                                  
    72 000000E0 B801000000                  mov rax, 1                      ; 1 - номер системного вызова функции write
    73 000000E5 BF01000000                  mov rdi, 1                      ; 1 - дескриптор файла стандартного вызова stdout
    74 000000EA 48BE-                       mov rsi, out_msg                ; адрес строки для вывода
    74 000000EC [1400000000000000] 
    75 000000F4 BA09000000                  mov rdx, len_out_msg            ; кол-во байт которое нужно записать
    76 000000F9 0F05                        syscall                         ; выполняем системный вызов write
    77                                  
    78 000000FB 4883F8FF                    cmp rax, -1                     ; сравниваем значение которое вернул write
    79 000000FF 0F8406010000                jz err                          ; если rax = -1 то переход на метку err
    80                                  
    81 00000105 B801000000                  mov rax, 1                      ; 1 - номер системного вызова функции write
    82 0000010A BF01000000                  mov rdi, 1                      ; 1 - дескриптор файла стандартного вызова stdout
    83 0000010F 48BE-                       mov rsi, result               ; адрес строки для вывода
    83 00000111 [8000000000000000] 
    84 00000119 48BA-                       mov rdx, len_read             ; кол-во байт которое нужно записать
    84 0000011B [1D00000000000000] 
    85                                      ;add rdx, 2                      ; перевод строки и нуль-терминатор
    86 00000123 0F05                        syscall                         ; выполняем системный вызов write
    87                                  
    88 00000125 4883F8FF                    cmp rax, -1                     ; сравниваем значение которое вернул write
    89 00000129 0F84DC000000                jz err                          ; если rax = length то переход на метку success
    90 0000012F E9CB000000                  jmp success                     ; иначе на метку err
    91                                  
    92                                  
    93                                  ; функция для перевода строки в число
    94                                  ; Вход: строка из buffer
    95                                  ; Выход: число в rax
    96                                  str_to_num:
    97 00000134 488B0C25[1D000000]          mov rcx, [len_read]       ; инициализируем счетчик длиной строки
    98 0000013C 48FFC9                      dec rcx
    99 0000013F 48BE-                       mov rsi, buffer           ; начало исходной строки
    99 00000141 [0000000000000000] 
   100 00000149 B800000000                  mov rax, 0                ; инициализируем rax нулем
   101 0000014E BB01000000                  mov rbx, 1                ; инициализируем rbx единицей(обозначает знак числа)
   102                                  
   103 00000153 8A16                        mov dl, [rsi]             ; считываем символ из буфера
   104 00000155 80FA2D                      cmp dl, '-'               ; сравнение со знаком "-"
   105 00000158 750D                        jne strloop               ; если считанный символ это не минус то переход к метке strloop
   106 0000015A 48FFC6                      inc rsi                   ; переход к следующему символу
   107 0000015D 48FFC9                      dec rcx                   ; увеличиваем счетчик цикла
   108 00000160 48C7C3FFFFFFFF              mov rbx, -1               ; число будет отрицательным
   109                                  
   110                                      strloop:                      ; цикл прохода по строке
   111 00000167 8A16                            mov dl, [rsi]             ; считываем символ из буфера
   112 00000169 486BC00A                        imul rax, 10              ; умножение значения в rax на 10 и присваивание результата rax
   113                                  
   114 0000016D 80EA30                          sub dl, '0'               ; перевод символа в число
   115 00000170 480FB6D2                        movzx rdx, dl             ; расширяем до 64 бит
   116 00000174 4801D0                          add rax, rdx              ; rax = rax + al
   117 00000177 48FFC6                          inc rsi                   ; переход к следующему символу
   118 0000017A E2EB                            loop strloop              ; уменьшаем счетчик rcx и переходим на метку strloop, если rcx != 0
   119 0000017C 480FAFC3                    imul rax, rbx
   120 00000180 C3                          ret
   121                                  
   122                                  
   123                                  ; функция для перевода числа в строку
   124                                  ; Вход: число в rax
   125                                  ; Выход: строка в result
   126                                  ;        длина строки в rdx
   127                                  num_to_str:
   128 00000181 48BE-                       mov rsi, buffer             ; начало строки с числом
   128 00000183 [0000000000000000] 
   129 0000018B BB01000000                  mov rbx, 1                  ; инициализируем rbx единицей(обозначает знак числа)
   130 00000190 B900000000                  mov rcx, 0                  ; длина строки с числом
   131                                  
   132 00000195 4883F800                    cmp rax, 0                  ; сравнение переводимого числа с нулем
   133 00000199 7D0E                        jge positive                 ; если больше нуля
   134                                  
   135                                      negative:                   ; иначе метка negative
   136 0000019B 48C7C3FFFFFFFF                  mov rbx, -1             ; число отрицательное
   137 000001A2 486BC0FF                        imul rax, -1            ; делаем число положительным, чтобы было легче перевести цифры
   138 000001A6 48FFC1                          inc rcx                 ; увеличиваем счетчик длины строки с числом
   139                                  
   140                                      positive:
   141 000001A9 4899                            cqo                     ; расширяем регистр RDX знаковым битом из RAX
   142 000001AB 48F73C25[3D000000]              idiv qword [divisor]    ; делим RDX:RAX на divisor, частное запишется в RAX, остаток в RDX
   143 000001B3 4883C230                        add rdx, '0'            ; преобразование в символ
   144 000001B7 8816                            mov byte [rsi], dl      ; записываем символ в буфер, но они будут идти наоборот
   145 000001B9 48FFC6                          inc rsi                 ; следующий символ в buffer
   146 000001BC 48FFC1                          inc rcx                 ; увеличиваем счетчик длины строки с числом
   147                                          
   148 000001BF 4883F800                        cmp rax, 0              ; пока RAX не равен 0, то продолжаем
   149 000001C3 75E4                            jne positive
   150                                  
   151                                      ; собираем итоговою строку с числом
   152 000001C5 48BF-                       mov rdi, result             ; начало строки 
   152 000001C7 [8000000000000000] 
   153 000001CF 4889CA                      mov rdx, rcx                ; записываем длину строки в другой регистр
   154 000001D2 48FFCE                      dec rsi                     ; чтобы указывал на последнюю цифру
   155                                  
   156 000001D5 4883FB01                    cmp rbx, 1                  ; отрицательное или положительное
   157 000001D9 7406                        je digits   
   158 000001DB C6072D                      mov byte [rdi], '-'         ; добавляем знак "-"
   159 000001DE 48FFC7                      inc rdi                     ; следующий символ
   160                                  
   161                                      digits:
   162 000001E1 8A06                            mov al, [rsi]           ; берем байт из buffer
   163 000001E3 8807                            mov [rdi], al           ; кладем байт в result
   164 000001E5 48FFCE                          dec rsi                 ; переход на предыдущее значение в buffer т.к. начинали с конца
   165 000001E8 48FFC7                          inc rdi                 ; следующий символ в result
   166 000001EB 48FFC9                          dec rcx                 ; уменьшаем счетчик
   167 000001EE 4885C9                          test rcx, rcx           ; проверка на равенство нулю
   168 000001F1 75EE                            jnz digits
   169 000001F3 C6070A                      mov byte [rdi], 10          ; добавляем в конец перевод строки
   170 000001F6 C6470100                    mov byte [rdi+1], 0         ; добавляем в конец нуль-терминатор
   171 000001FA 4883C202                    add rdx, 2                  ; учитываем в длине перевод и нуль-терминатор
   172                                  
   173 000001FE C3                          ret
   174                                  
   175                                  
   176                                  ; успешное завершение программы
   177                                  success:   
   178 000001FF B83C000000                  mov rax, 60                    ; 60 - номер системного вызова exit         
   179 00000204 BF00000000                  mov rdi, 0
   180 00000209 0F05                        syscall                        ; выполняем системный вызов exit
   181                                  
   182                                  ; завершение программы с ошибкой
   183                                  err:
   184 0000020B B83C000000                  mov rax, 60                    ; 60 - номер системного вызова exit
   185 00000210 48C7C7FFFFFFFF              mov rdi, -1
   186 00000217 0F05                        syscall                        ; выполняем системный вызов exit
